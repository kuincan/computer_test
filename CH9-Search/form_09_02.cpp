/**
 * Find The Multiple
 * 给定一个正数n，只需要找出n的某一非负倍数m，它仅由0和1组成
 * 假定n<=200，并且有对应的不超过100位数的m
 * 
 * INPUT:
 * n //n==0表示程序结束
 * OUTPUT:
 * 每一个n都有对应的数m，且m不超过100位数，若对于n有多个解，输出任一即可
 * 
 * e.g.
 * INPUT:
 * 2
 * 6
 * 19
 * 0
 * OUTPUT:
 * 10
 * 100100100100100100
 * 111111111111111111
 * 
 * 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100
 * 因为满足条件的n的倍数可能会超过整型所能表示的范围，所以会要用到字符串，但是书中所配的代码没有考虑
 * 其实这里和之前第六章写的BigInteger可以结合一下，就可以直接用乘法求了
 * 
 * 但是这题因为只要找到仅有0和1组成的数，而这种数对于整数集来说是很少的
 * 则只需利用0和1组成的数，然后判断其是否能整除n来确定它是否是n的倍数
 * 
 * 将一个仅有0和1组成的数num作为初始状态，其邻居状态必然是10*num和10*num+1，这两个数也必然是仅由0和1组成的
 * 所以10*num和10*num+1就是扩展状态
 * 
 * 总结一下BFS:
 * ①状态：确定所求解问题中的状态。通过状态的扩展，遍历所有的状态，从中寻找需要的答案
 * ②状态扩展方式：在BFS中，需要尽可能地扩展状态，并对先扩展得到的状态先进性下一次状态扩展
 * ③有效状态：对有些状态，不需要再次扩展，而是直接舍弃它
 * ④队列：为了使先得出的状态能够先扩展，所以使用队列，将得到的状态依次放入队尾，每次取队头状态进行扩展
 * ⑤标记：为了判断有效与无效状态，常常需要运用标记，例如form9.1的visit
 * ⑥有效状态数：有效状态数与算法的时间复杂度同数量级，所以在继续宁搜索之前，必须估算其是否在能够接受的范围内
 * ⑦最优：BFS常用来求解最优值问题，因此，一旦问题中出现最少、最短、最优等关键字，就要考虑是否可以用BFS
 * 
 **/
#include <iostream>
#include <queue>
using namespace std;

typedef long long ll; 

void BFS(int n){
    queue<ll> myQueue;
    myQueue.push(1); //初始状态，仅由0和1组成
    while (!myQueue.empty())
    {
        ll cur = myQueue.front();
        myQueue.pop();
        if (cur % n == 0)
        {
            cout << cur << endl;
            return;
        }
        myQueue.push(cur*10);
        myQueue.push(cur*10+1);
    }
    return;
}

int main(){
    int n;
    while (cin >> n)
    {
        if (n == 0)
            break;
        BFS(n);
    }
    return 0;
}